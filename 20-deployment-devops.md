# 20. Deployment & DevOps

## Table of Contents

- [Kamal (Rails 8 Default)](#kamal-rails-8-default)
- [Docker for Rails](#docker-for-rails)
- [Puma Configuration](#puma-configuration)
- [CI/CD Pipelines](#cicd-pipelines)
- [Environment Management](#environment-management)
- [Monitoring & Logging](#monitoring--logging)
- [Health Checks](#health-checks)
- [Zero-Downtime Deployments](#zero-downtime-deployments)
- [Backup & Recovery](#backup--recovery)
- [Security in Production](#security-in-production)
- [Platform-Specific Deployment](#platform-specific-deployment)

---

## Kamal (Rails 8 Default)

Kamal is Rails' default deployment tool since Rails 8. It deploys containerized applications to any server using Docker.

### Initial Setup

```bash
# Already included in Rails 8 apps
# For existing apps:
bundle add kamal
kamal init
```

### Configuration — `config/deploy.yml`

```yaml
# config/deploy.yml
service: myapp

# Docker image name
image: myregistry/myapp

# Servers to deploy to
servers:
  web:
    hosts:
      - 192.168.0.1
      - 192.168.0.2
    labels:
      traefik.http.routers.myapp.rule: Host(`myapp.com`)
    options:
      memory: 512m
  job:
    hosts:
      - 192.168.0.3
    cmd: bin/jobs  # Solid Queue supervisor

# Docker registry credentials
registry:
  server: ghcr.io
  username: myuser
  password:
    - KAMAL_REGISTRY_PASSWORD

# Load balancer (Traefik by default)
proxy:
  ssl: true
  host: myapp.com

# Environment variables
env:
  clear:
    RAILS_LOG_LEVEL: info
    RAILS_SERVE_STATIC_FILES: true
  secret:
    - RAILS_MASTER_KEY
    - DATABASE_URL
    - REDIS_URL

# Accessories (databases, Redis, etc.)
accessories:
  db:
    image: postgres:16
    host: 192.168.0.1
    port: "127.0.0.1:5432:5432"
    env:
      clear:
        POSTGRES_DB: myapp_production
      secret:
        - POSTGRES_PASSWORD
    directories:
      - data:/var/lib/postgresql/data
    options:
      memory: 1g

  redis:
    image: redis:7
    host: 192.168.0.1
    port: "127.0.0.1:6379:6379"
    directories:
      - data:/data

# Health check
healthcheck:
  path: /up
  port: 3000
  interval: 10
  max_attempts: 30

# Asset bridging — keep old assets during transition
asset_path: /rails/public/assets

# Hooks
hooks:
  pre-connect:
    local: bin/kamal/pre-connect
```

### Kamal Commands

```bash
# First deploy — sets up servers
kamal setup

# Deploy latest code
kamal deploy

# Rollback to previous version
kamal rollback

# View logs
kamal app logs
kamal app logs -f            # Follow
kamal app logs --grep error  # Filter

# Run console on production
kamal app exec -i "bin/rails console"

# Run migrations
kamal app exec "bin/rails db:migrate"

# Check status
kamal details

# Manage accessories
kamal accessory boot db
kamal accessory reboot redis

# Environment secrets
kamal envify                 # Create .env from secrets
```

### Secrets Management with Kamal

```bash
# .kamal/secrets — source of secrets (not committed to git)
RAILS_MASTER_KEY=$(cat config/master.key)
DATABASE_URL=postgres://user:pass@db:5432/myapp
KAMAL_REGISTRY_PASSWORD=ghp_xxx

# .kamal/secrets can reference 1Password, AWS SSM, etc.
RAILS_MASTER_KEY=$(op read "op://Production/Rails/master_key")
```

---

## Docker for Rails

### Rails 8 Default Dockerfile

```dockerfile
# Dockerfile — generated by Rails 8
# syntax=docker/dockerfile:1

# Base image
ARG RUBY_VERSION=3.3.0
FROM docker.io/library/ruby:$RUBY_VERSION-slim AS base

WORKDIR /rails

# Set production environment
ENV RAILS_ENV="production" \
    BUNDLE_DEPLOYMENT="1" \
    BUNDLE_PATH="/usr/local/bundle" \
    BUNDLE_WITHOUT="development:test"

# Build stage — install dependencies and compile assets
FROM base AS build

# Install build dependencies
RUN apt-get update -qq && \
    apt-get install --no-install-recommends -y \
    build-essential \
    git \
    libpq-dev \
    pkg-config && \
    rm -rf /var/lib/apt/lists /var/cache/apt/archives

# Install gems
COPY Gemfile Gemfile.lock ./
RUN bundle install && \
    rm -rf ~/.bundle/ "${BUNDLE_PATH}"/ruby/*/cache "${BUNDLE_PATH}"/ruby/*/bundler/gems/*/.git

# Copy application code
COPY . .

# Precompile bootsnap code for faster boot times
RUN bundle exec bootsnap precompile app/ lib/

# Precompile assets
RUN SECRET_KEY_BASE_DUMMY=1 ./bin/rails assets:precompile

# Final stage — runtime
FROM base

# Install runtime dependencies
RUN apt-get update -qq && \
    apt-get install --no-install-recommends -y \
    curl \
    libpq-dev \
    libjemalloc2 && \
    rm -rf /var/lib/apt/lists /var/cache/apt/archives

# Use jemalloc for better memory management
ENV LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.2
ENV MALLOC_CONF="dirty_decay_ms:1000,narenas:2"

# Copy built artifacts
COPY --from=build "${BUNDLE_PATH}" "${BUNDLE_PATH}"
COPY --from=build /rails /rails

# Create non-root user
RUN groupadd --system --gid 1000 rails && \
    useradd rails --uid 1000 --gid 1000 --create-home --shell /bin/bash && \
    chown -R rails:rails db log storage tmp
USER 1000:1000

# Entrypoint for migrations and setup
ENTRYPOINT ["/rails/bin/docker-entrypoint"]

EXPOSE 3000
CMD ["./bin/rails", "server"]
```

### Docker Entrypoint

```bash
#!/bin/bash -e
# bin/docker-entrypoint

# Enable jemalloc for reduced memory usage and target fragmentation
if [ -z "${LD_PRELOAD+x}" ] && [ -f /usr/lib/x86_64-linux-gnu/libjemalloc.so.2 ]; then
  export LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so.2
fi

# Run pending migrations automatically on deploy
if [ "${RAILS_ENV}" = "production" ]; then
  ./bin/rails db:prepare
fi

exec "${@}"
```

### .dockerignore

```
# .dockerignore
.git
.gitignore
log/*
tmp/*
storage/*
node_modules
.bundle
vendor/bundle
.env*
.kamal
config/master.key
config/credentials/*.key
```

---

## Puma Configuration

```ruby
# config/puma.rb

# Thread pool — min and max threads
max_threads_count = ENV.fetch("RAILS_MAX_THREADS", 5)
min_threads_count = ENV.fetch("RAILS_MIN_THREADS") { max_threads_count }
threads min_threads_count, max_threads_count

# Port
port ENV.fetch("PORT", 3000)

# Environment
environment ENV.fetch("RAILS_ENV", "development")

# Workers (processes) — use for production
# Rule of thumb: 1 worker per CPU core
workers ENV.fetch("WEB_CONCURRENCY", 2)

# Preload app for faster worker boot + CoW memory savings
preload_app!

# Worker boot hook
on_worker_boot do
  ActiveRecord::Base.establish_connection if defined?(ActiveRecord)
end

# PID file
pidfile ENV.fetch("PIDFILE", "tmp/pids/server.pid")

# Allow Puma to be restarted by `bin/rails restart`
plugin :tmp_restart

# Solid Queue integration (Rails 8)
plugin :solid_queue if ENV.fetch("SOLID_QUEUE_IN_PUMA", false)

# Worker timeout
worker_timeout 60

# Bind to all interfaces (for Docker)
bind "tcp://0.0.0.0:#{ENV.fetch('PORT', 3000)}"
```

### Puma Sizing Guidelines

```
# Memory calculation:
# Base memory per worker: ~200-400MB for typical Rails app
# Memory per thread: ~10-50MB additional

# Example: 2GB RAM server
# Workers: 2-3 (leave room for OS, DB, Redis)
# Threads: 5 per worker
# Total concurrent requests: 10-15

# CPU-bound apps: workers = CPU cores, threads = 1-3
# IO-bound apps (typical Rails): workers = CPU cores, threads = 5
# Memory-constrained: fewer workers, more threads
```

---

## CI/CD Pipelines

### GitHub Actions

```yaml
# .github/workflows/ci.yml
name: CI

on:
  pull_request:
  push:
    branches: [main]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true
      - run: bundle exec rubocop

  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: myapp_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"

    env:
      RAILS_ENV: test
      DATABASE_URL: postgres://postgres:postgres@localhost:5432/myapp_test
      REDIS_URL: redis://localhost:6379/0

    steps:
      - uses: actions/checkout@v4

      - uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Setup database
        run: bin/rails db:schema:load

      - name: Run tests
        run: bin/rails test

      - name: Run system tests
        run: bin/rails test:system

  security:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true
      - run: bundle exec brakeman --no-pager

  deploy:
    needs: [lint, test, security]
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true
      - run: kamal deploy
        env:
          KAMAL_REGISTRY_PASSWORD: ${{ secrets.KAMAL_REGISTRY_PASSWORD }}
```

### Pre-Commit Hooks

```bash
# bin/ci — local CI script
#!/usr/bin/env bash
set -euo pipefail

echo "=== Running Rubocop ==="
bundle exec rubocop

echo "=== Running Brakeman ==="
bundle exec brakeman --quiet --no-pager

echo "=== Running Tests ==="
bin/rails test

echo "=== All checks passed ==="
```

### Recommended CI Checks

```
1. Linting        — RuboCop (code style)
2. Security       — Brakeman (static analysis), bundler-audit (gem vulnerabilities)
3. Unit tests     — bin/rails test (or rspec)
4. System tests   — bin/rails test:system (browser tests)
5. Database       — Verify migrations are reversible
6. Assets         — Verify assets precompile successfully
```

---

## Environment Management

### Rails Credentials (Preferred)

```bash
# Edit credentials for specific environment
EDITOR="code --wait" bin/rails credentials:edit --environment production
EDITOR="code --wait" bin/rails credentials:edit --environment staging

# Credentials file structure
# config/credentials/production.yml.enc (encrypted)
# config/credentials/production.key (decryption key — NEVER commit)

# Access in code
Rails.application.credentials.aws[:access_key_id]
Rails.application.credentials.dig(:stripe, :secret_key)
```

### Credentials File Structure

```yaml
# config/credentials/production.yml.enc (decrypted view)
aws:
  access_key_id: AKIA...
  secret_access_key: wJa...
  bucket: myapp-production

stripe:
  publishable_key: pk_live_...
  secret_key: sk_live_...

smtp:
  user_name: apikey
  password: SG...

secret_key_base: abc123...
```

### Environment Variables

```ruby
# For infrastructure config (not secrets)
# Set in server environment, Docker, or .env files

# config/database.yml
production:
  url: <%= ENV["DATABASE_URL"] %>

# config/environments/production.rb
config.action_mailer.smtp_settings = {
  address: ENV.fetch("SMTP_HOST", "smtp.sendgrid.net"),
  port: ENV.fetch("SMTP_PORT", 587).to_i,
  user_name: Rails.application.credentials.dig(:smtp, :user_name),
  password: Rails.application.credentials.dig(:smtp, :password)
}

# Use ENV.fetch with defaults for required values
port = ENV.fetch("PORT", 3000)
# Use ENV["KEY"] when nil is acceptable
optional_flag = ENV["FEATURE_FLAG"]
```

### Multi-Environment Setup

```
config/
├── credentials/
│   ├── development.yml.enc   # Development secrets
│   ├── development.key       # (gitignored)
│   ├── staging.yml.enc       # Staging secrets
│   ├── staging.key           # (gitignored)
│   ├── production.yml.enc    # Production secrets
│   └── production.key        # (gitignored)
├── environments/
│   ├── development.rb        # Dev config
│   ├── test.rb               # Test config
│   ├── staging.rb            # Staging config (custom)
│   └── production.rb         # Production config
└── database.yml              # Per-environment DB config
```

### Adding Custom Environments

```ruby
# config/environments/staging.rb
# Copy from production.rb and adjust:
Rails.application.configure do
  config.cache_classes = true
  config.eager_load = true
  config.log_level = :info

  # Staging-specific settings
  config.action_mailer.default_url_options = { host: "staging.myapp.com" }
end

# config/database.yml
staging:
  <<: *default
  url: <%= ENV["DATABASE_URL"] %>
```

---

## Monitoring & Logging

### Structured Logging

```ruby
# config/environments/production.rb

# JSON logging for production (easier to parse)
config.log_formatter = ::Logger::Formatter.new

# Use tagged logging
config.log_tags = [:request_id]

# Or custom log tags
config.log_tags = [
  :request_id,
  ->(request) { request.remote_ip },
  ->(request) { request.user_agent }
]

# Log level
config.log_level = ENV.fetch("RAILS_LOG_LEVEL", "info").to_sym

# Silence health check noise
config.silence_healthcheck_path = "/up"
```

### Lograge (Cleaner Logs)

```ruby
# Gemfile
gem "lograge"

# config/initializers/lograge.rb
Rails.application.configure do
  config.lograge.enabled = true
  config.lograge.formatter = Lograge::Formatters::Json.new

  config.lograge.custom_payload do |controller|
    {
      user_id: controller.current_user&.id,
      request_id: controller.request.request_id
    }
  end

  config.lograge.custom_options = ->(event) {
    {
      params: event.payload[:params].except("controller", "action", "format"),
      exception: event.payload[:exception]&.first,
      time: Time.current.iso8601
    }
  }
end

# Output example (single line per request):
# {"method":"GET","path":"/posts","format":"html","controller":"PostsController",
#  "action":"index","status":200,"duration":45.2,"view":30.1,"db":15.1,
#  "user_id":123,"request_id":"abc-123"}
```

### Error Tracking

```ruby
# Sentry — recommended for error tracking
# Gemfile
gem "sentry-ruby"
gem "sentry-rails"

# config/initializers/sentry.rb
Sentry.init do |config|
  config.dsn = Rails.application.credentials.dig(:sentry, :dsn)
  config.environment = Rails.env
  config.release = ENV["GIT_SHA"] || `git rev-parse HEAD`.strip

  # Performance monitoring
  config.traces_sample_rate = Rails.env.production? ? 0.1 : 1.0

  # Filter sensitive data
  config.before_send = ->(event, hint) {
    event.request.data = "[FILTERED]" if event.request&.data
    event
  }

  # Ignore common noise
  config.excluded_exceptions += [
    "ActionController::RoutingError",
    "ActionController::BadRequest"
  ]
end

# Manual error capture
begin
  risky_operation
rescue => e
  Sentry.capture_exception(e, extra: { context: "relevant info" })
  raise
end

# Add context
Sentry.set_user(id: current_user.id, email: current_user.email)
Sentry.set_tags(feature: "checkout")
```

### Application Metrics

```ruby
# Track custom metrics with ActiveSupport::Notifications
ActiveSupport::Notifications.instrument("order.created", {
  order_id: order.id,
  total: order.total
})

# Subscribe to metrics
ActiveSupport::Notifications.subscribe("order.created") do |*args|
  event = ActiveSupport::Notifications::Event.new(*args)
  StatsD.increment("orders.created")
  StatsD.measure("orders.total", event.payload[:total])
end

# Built-in Rails notifications to monitor:
# process_action.action_controller  — request timing
# sql.active_record                 — query timing
# cache_read.active_support         — cache hits/misses
# deliver.action_mailer             — email delivery
# perform.active_job                — job execution
```

---

## Health Checks

### Rails 8 Built-in Health Check

```ruby
# config/routes.rb
# Automatically added in Rails 8
Rails.application.routes.draw do
  get "up" => "rails/health#show", as: :rails_health_check
end

# Returns 200 OK if app boots successfully
# Used by Kamal, load balancers, Kubernetes
```

### Custom Health Check

```ruby
# app/controllers/health_controller.rb
class HealthController < ApplicationController
  skip_before_action :authenticate_user!

  # Simple liveness check
  def show
    head :ok
  end

  # Detailed readiness check
  def ready
    checks = {
      database: database_connected?,
      redis: redis_connected?,
      migrations: migrations_current?
    }

    if checks.values.all?
      render json: { status: "ok", checks: checks }
    else
      render json: { status: "degraded", checks: checks }, status: :service_unavailable
    end
  end

  private

  def database_connected?
    ActiveRecord::Base.connection.execute("SELECT 1")
    true
  rescue StandardError
    false
  end

  def redis_connected?
    Redis.current.ping == "PONG"
  rescue StandardError
    false
  end

  def migrations_current?
    !ActiveRecord::Base.connection.migration_context.needs_migration?
  rescue StandardError
    false
  end
end

# config/routes.rb
get "up", to: "health#show"
get "health", to: "health#ready"
```

---

## Zero-Downtime Deployments

### Database Migrations Without Downtime

Use the `strong_migrations` gem to catch unsafe migrations.

```ruby
# Gemfile
gem "strong_migrations"

# config/initializers/strong_migrations.rb
StrongMigrations.start_after = 20240101000000  # Only check new migrations

# UNSAFE migrations that lock tables:
# - Adding a column with a default (pre-Rails 7)
# - Adding an index without CONCURRENTLY
# - Changing column type
# - Renaming a column/table

# SAFE patterns:

# Adding a column (Rails 7+ adds defaults safely)
add_column :users, :role, :string, default: "member"

# Adding an index concurrently (PostgreSQL)
class AddIndexToUsersEmail < ActiveRecord::Migration[7.1]
  disable_ddl_transaction!  # Required for concurrent index

  def change
    add_index :users, :email, algorithm: :concurrently
  end
end

# Renaming a column safely (multi-step):
# Step 1: Add new column
add_column :users, :full_name, :string
# Step 2: Backfill data (in batches)
User.in_batches.update_all("full_name = name")
# Step 3: Update code to use new column
# Step 4: Remove old column (next deploy)
safety_assured { remove_column :users, :name }
```

### Deployment Order Convention

```
1. Deploy code that works with BOTH old and new schema
2. Run migrations
3. Deploy code that uses new schema only
4. Clean up old columns/tables in future migration

# For Kamal, migrations run in docker-entrypoint automatically
```

---

## Backup & Recovery

### Database Backups

```bash
# PostgreSQL backup
pg_dump -Fc myapp_production > backup_$(date +%Y%m%d_%H%M%S).dump

# Restore
pg_restore -d myapp_production backup_20240115_120000.dump

# Automated backup script
#!/bin/bash
# bin/backup
set -euo pipefail

TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="myapp_${TIMESTAMP}.dump"
S3_BUCKET="myapp-backups"

pg_dump -Fc "$DATABASE_URL" > "/tmp/${BACKUP_FILE}"
aws s3 cp "/tmp/${BACKUP_FILE}" "s3://${S3_BUCKET}/${BACKUP_FILE}"
rm "/tmp/${BACKUP_FILE}"

# Clean up backups older than 30 days
aws s3 ls "s3://${S3_BUCKET}/" | \
  awk '{print $4}' | \
  while read file; do
    # Parse date and delete if older than 30 days
    ...
  done
```

### Active Storage Backups

```ruby
# If using Active Storage with S3, enable versioning on the bucket
# If using local disk, include storage/ in backups

# config/storage.yml
amazon:
  service: S3
  access_key_id: <%= Rails.application.credentials.dig(:aws, :access_key_id) %>
  secret_access_key: <%= Rails.application.credentials.dig(:aws, :secret_access_key) %>
  region: us-east-1
  bucket: myapp-production
```

---

## Security in Production

### Production Security Checklist

```ruby
# config/environments/production.rb

# Force SSL
config.force_ssl = true

# Secure cookies
config.session_store :cookie_store,
  key: "_myapp_session",
  secure: true,
  httponly: true,
  same_site: :lax

# Security headers (use secure_headers gem or set manually)
config.action_dispatch.default_headers = {
  "X-Frame-Options" => "SAMEORIGIN",
  "X-Content-Type-Options" => "nosniff",
  "X-XSS-Protection" => "0",
  "Permissions-Policy" => "camera=(), microphone=(), geolocation=()",
  "Referrer-Policy" => "strict-origin-when-cross-origin"
}

# Filter sensitive parameters from logs
config.filter_parameters += [
  :passw, :secret, :token, :_key, :crypt, :salt,
  :certificate, :otp, :ssn, :credit_card
]

# Filter redirect URLs
config.filter_redirect += [/token/, /secret/]
```

### Dependency Security

```bash
# Check gems for known vulnerabilities
# Gemfile
group :development do
  gem "bundler-audit"
  gem "brakeman"
end

# Run security checks
bundle audit check --update    # Check gem vulnerabilities
bundle exec brakeman           # Static analysis for Rails security issues

# In CI — fail build on vulnerabilities
bundle audit check --update || exit 1
bundle exec brakeman --exit-on-warn --no-pager || exit 1
```

### Key Rotation

```bash
# Rotate Rails master key
# 1. Generate new key
EDITOR="code --wait" bin/rails credentials:edit --environment production
# 2. Update key in deployment secrets
# 3. Deploy
```

---

## Platform-Specific Deployment

### Kamal to VPS (Hetzner, DigitalOcean, etc.)

```yaml
# config/deploy.yml — simplest production setup
service: myapp
image: ghcr.io/myuser/myapp

servers:
  web:
    hosts:
      - 49.13.xx.xx
  job:
    hosts:
      - 49.13.xx.xx
    cmd: bin/jobs

proxy:
  ssl: true
  host: myapp.com

env:
  secret:
    - RAILS_MASTER_KEY
    - DATABASE_URL

accessories:
  db:
    image: postgres:16
    host: 49.13.xx.xx
    port: "127.0.0.1:5432:5432"
    env:
      secret:
        - POSTGRES_PASSWORD
    directories:
      - data:/var/lib/postgresql/data
```

### Render / Fly.io / Railway

```bash
# Render — render.yaml
services:
  - type: web
    name: myapp
    runtime: ruby
    buildCommand: bundle install && bin/rails assets:precompile
    startCommand: bin/rails server -b 0.0.0.0
    envVars:
      - key: RAILS_ENV
        value: production
      - key: RAILS_MASTER_KEY
        sync: false

# Fly.io
fly launch          # Auto-detects Rails
fly deploy          # Deploy
fly ssh console     # SSH into container
fly postgres create # Managed PostgreSQL
```

### Heroku (Legacy but Common)

```bash
# Procfile
web: bundle exec puma -C config/puma.rb
worker: bundle exec rake solid_queue:start
release: bin/rails db:migrate

# Add buildpacks
heroku buildpacks:set heroku/ruby

# Config
heroku config:set RAILS_MASTER_KEY=$(cat config/credentials/production.key)
heroku config:set RAILS_ENV=production
heroku config:set RAILS_SERVE_STATIC_FILES=true
```

---

## Deployment Checklist

### Pre-Deployment

- [ ] All CI checks pass (tests, linting, security)
- [ ] Database migrations are safe (checked with `strong_migrations`)
- [ ] Credentials encrypted and keys securely stored
- [ ] `config.force_ssl = true` in production
- [ ] `config.eager_load = true` in production
- [ ] Assets precompile successfully
- [ ] Health check endpoint configured (`/up`)
- [ ] Error tracking configured (Sentry or equivalent)
- [ ] Log level appropriate (`info` for production)

### Infrastructure

- [ ] Database backups automated and tested
- [ ] SSL/TLS certificates configured (auto-renew via Let's Encrypt)
- [ ] DNS configured correctly
- [ ] CDN for static assets (if applicable)
- [ ] Redis/cache store provisioned
- [ ] Background job processor running (Solid Queue)
- [ ] Sufficient server resources (CPU, RAM, disk)
- [ ] Firewall rules configured (only expose necessary ports)

### Post-Deployment

- [ ] Health check returns 200
- [ ] Verify key user flows work
- [ ] Check error tracking for new errors
- [ ] Monitor response times for regression
- [ ] Verify background jobs are processing
- [ ] Verify emails are sending
- [ ] Check logs for warnings or errors

### Rollback Plan

- [ ] Know how to rollback: `kamal rollback`
- [ ] Database migration is reversible
- [ ] Previous Docker image is available
- [ ] Communication plan for extended outages
